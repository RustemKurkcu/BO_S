#!/usr/bin/env Rscript
suppressWarnings(suppressMessages({ }))

# ---- args ----
args <- commandArgs(trailingOnly = TRUE)
opt <- list()
if (length(args) > 0) {
  for (i in seq(1, length(args), by=2)) {
    key <- gsub("^--","", args[i]); val <- if (i+1 <= length(args)) args[i+1] else ""
    opt[[key]] <- val
  }
}
counts_path <- opt[["counts"]]
meta_path   <- opt[["meta"]]
outdir      <- if (!is.null(opt[["outdir"]])) opt[["outdir"]] else "results/figures/main"
prefix      <- if (!is.null(opt[["prefix"]])) opt[["prefix"]] else format(Sys.time(), "%Y%m%d_acf")
dir.create(outdir, recursive = TRUE, showWarnings = FALSE)

# ---- IO helpers ----
read_csv <- function(p) {
  x <- read.csv(p, check.names = FALSE, stringsAsFactors = FALSE)
  if (ncol(x) > 1 && !is.numeric(x[[1]])) { rn <- x[[1]]; x <- x[,-1, drop=FALSE]; rownames(x) <- rn }
  return(x)
}

# ---- counts ----
if (is.null(counts_path) || counts_path=="" || !file.exists(counts_path)) stop("Provide --counts")
counts <- read_csv(counts_path)
counts[] <- lapply(counts, function(v) suppressWarnings(as.numeric(v)))
counts <- as.matrix(counts)
counts <- counts[rowSums(is.finite(counts)) > 0, , drop=FALSE]

# ---- metadata (optional; auto if missing) ----
autogen_meta <- FALSE
if (!is.null(meta_path) && meta_path!="" && file.exists(meta_path)) {
  meta <- read.csv(meta_path, stringsAsFactors = FALSE, check.names = FALSE)
  cs <- tolower(colnames(meta))
  if (!"sample" %in% cs) stop("metadata CSV must contain a 'sample' column")
  rownames(meta) <- meta[[which(cs=="sample")]]
} else {
  autogen_meta <- TRUE
  samples <- colnames(counts)
  infer <- function(s,re) grepl(re, s, ignore.case=TRUE)
  condition  <- ifelse(infer(samples,"ACF"), "ACF",
                  ifelse(infer(samples,"Norm|Normal|Ctrl|Control"), "Normal", "Unknown"))
  compartment <- ifelse(infer(samples,"epi|epith"), "Epithelial",
                   ifelse(infer(samples,"str|stro|stroma"), "Stromal", "Unknown"))
  meta <- data.frame(sample=samples, condition=condition, compartment=compartment,
                     stringsAsFactors=FALSE, row.names=samples)
  dir.create("data/raw/acf/metadata", recursive=TRUE, showWarnings=FALSE)
  outm <- file.path("data/raw/acf/metadata", paste0("autogenerated_meta_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv"))
  write.csv(meta, outm, row.names=FALSE)
}

# ---- align + PCA ----
common <- intersect(colnames(counts), rownames(meta))
if (length(common) < 3) stop("Not enough overlapping samples between counts and metadata.")
counts <- counts[, common, drop=FALSE]
meta   <- meta[common, , drop=FALSE]

X <- t(scale(t(counts), center=TRUE, scale=TRUE)); X[!is.finite(X)] <- 0
pc <- prcomp(t(X), center=FALSE, scale.=FALSE)

cond <- factor(meta$condition); comp <- factor(meta$compartment)
pch_map <- setNames(seq_along(levels(comp)), levels(comp))
col_map <- setNames(seq_along(levels(cond)), levels(cond))

pdf(file.path(outdir, paste0(prefix, "_PCA_samples.pdf")), width=6, height=5)
plot(pc$x[,1], pc$x[,2],
     xlab=paste0("PC1 (", round(summary(pc)$importance[2,1]*100,1), "%)"),
     ylab=paste0("PC2 (", round(summary(pc)$importance[2,2]*100,1), "%)"),
     main="ACF normalized – PCA",
     pch=pch_map[as.character(comp)], col=col_map[as.character(cond)])
legend("topright", legend=paste(levels(cond), "(color) /", levels(comp), "(shape)"), bty="n")
grid(); dev.off()

# ---- heatmap (top var genes) ----
rowvar <- apply(counts, 1, var, na.rm=TRUE)
keep <- names(sort(rowvar, decreasing=TRUE))[seq_len(min(200, sum(is.finite(rowvar))))]
H <- counts[keep, , drop=FALSE]; H <- t(scale(t(H))); H[!is.finite(H)] <- 0
pdf(file.path(outdir, paste0(prefix, "_Heatmap_topVarGenes.pdf")), width=7, height=9)
heatmap(H, Colv=NA, scale="none", margins=c(6,6), main="ACF – Top variable genes")
dev.off()

# ---- run log ----
logf <- file.path(outdir, paste0(prefix, "_runlog.txt"))
sink(logf)
cat("Counts:", counts_path, "\n")
cat("Samples:", ncol(counts), " Genes:", nrow(counts), "\n")
cat("Autogenerated metadata:", autogen_meta, "\n")
print(table(meta$condition, useNA="ifany"))
print(table(meta$compartment, useNA="ifany"))
sink()